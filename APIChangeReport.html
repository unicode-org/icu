<html>
<!--
<i><font size="-1">Contents generated by StableAPI tool on Wed Jun 25 17:05:24 PDT 2008<br>Copyright (C) 2008, International Business Machines Corporation, All Rights Reserved.</font></i>
-->

<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>ICU4C API Comparison: ICU 3.8.1 with ICU 4.0</title>
</head>
<body>
<h1>ICU4C API Comparison: ICU 3.8.1 with ICU 4.0</h1>
<hr>
<h2>Removed from ICU 3.8.1</h2>
<table BORDER="1">
<THEAD>
<tr>
<th>File</th><th>Public API Prototype</th><th>ICU 3.8.1</th><th>ICU 4.0</th>
</tr>
</THEAD>
<tr STYLE="color: red">
<td>LESwaps.h</td><td>static le_uint32 LESwaps::swapLong(le_uint32 value)</td><td>Stable</td><td>None</td>
</tr>
<tr STYLE="color: red">
<td>LESwaps.h</td><td>static le_uint16 LESwaps::swapWord(le_uint16 value)</td><td>Stable</td><td>None</td>
</tr>
<tr STYLE="color: red">
<td>LESwaps.h</td><td>static le_uint8 LESwaps::isBigEndian()</td><td>Stable</td><td>None</td>
</tr>
<tr STYLE="">
<td>msgfmt.h</td><td>UBool MessageFormat::Subformat::operator!=(const Subformat &amp;that) const</td><td>Internal</td><td>None</td>
</tr>
<tr STYLE="">
<td>msgfmt.h</td><td>UBool MessageFormat::Subformat::operator==(const Subformat &amp;that) const</td><td>Internal</td><td>None</td>
</tr>
<tr STYLE="">
<td>msgfmt.h</td><td>Subformat&amp; MessageFormat::Subformat::operator=(const Subformat &amp;that)</td><td>Internal</td><td>None</td>
</tr>
<tr STYLE="">
<td>ucol.h</td><td>int32_t ucol_identifierToShortString(uint32_t identifier, char *buffer, int32_t capacity, UBool forceDefaults, UErrorCode *status)</td><td>Internal</td><td>None</td>
</tr>
<tr STYLE="">
<td>ucol.h</td><td>UCollator* ucol_openFromIdentifier(uint32_t identifier, UBool forceDefaults, UErrorCode *status)</td><td>Internal</td><td>None</td>
</tr>
<tr STYLE="">
<td>ucol.h</td><td>uint32_t ucol_collatorToIdentifier(const UCollator *coll, const char *locale, UErrorCode *status)</td><td>Internal</td><td>None</td>
</tr>
<tr STYLE="">
<td>ucol.h</td><td>uint32_t ucol_shortStringToIdentifier(const char *definition, UBool forceDefaults, UErrorCode *status)</td><td>Internal</td><td>None</td>
</tr>
</table>
<P></P>
<hr>
<h2>Deprecated or Obsoleted in ICU 4.0</h2>
<table BORDER="1">
<THEAD>
<tr>
<th>File</th><th>Public API Prototype</th><th>ICU 3.8.1</th><th>ICU 4.0</th>
</tr>
</THEAD>
</table>
<P></P>
<hr>
<h2>Changed in  ICU 4.0 (old, new)</h2>
<table BORDER="1">
<THEAD>
<tr>
<th>File</th><th>Public API Prototype</th><th>ICU 3.8.1</th><th>ICU 4.0</th>
</tr>
</THEAD>
<tr STYLE="">
<td>basictz.h</td><td>BasicTimeZone::~BasicTimeZone()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>basictz.h</td><td>UBool BasicTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)=0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>basictz.h</td><td>int32_t BasicTimeZone::countTransitionRules(UErrorCode &amp;status)=0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>basictz.h</td><td>UBool BasicTimeZone::hasEquivalentTransitions(BasicTimeZone &amp;tz, UDate start, UDate end, UBool ignoreDstAmount, UErrorCode &amp;ec)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>basictz.h</td><td>void BasicTimeZone::getTimeZoneRules(const InitialTimeZoneRule *&amp;initial, const TimeZoneRule *trsrules[], int32_t &amp;trscount, UErrorCode &amp;status)=0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>basictz.h</td><td>UBool BasicTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)=0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>basictz.h</td><td>void BasicTimeZone::getSimpleRulesNear(UDate date, InitialTimeZoneRule *&amp;initial, AnnualTimeZoneRule *&amp;std, AnnualTimeZoneRule *&amp;dst, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>const UnicodeString&amp; DateTimePatternGenerator::getDateTimeFormat() const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>void DateTimePatternGenerator::setDecimal(const UnicodeString &amp;decimal)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>const UnicodeString&amp; DateTimePatternGenerator::getPatternForSkeleton(const UnicodeString &amp;skeleton) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UnicodeString DateTimePatternGenerator::getBestPattern(const UnicodeString &amp;skeleton, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>void DateTimePatternGenerator::setDateTimeFormat(const UnicodeString &amp;dateTimeFormat)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UBool DateTimePatternGenerator::operator!=(const DateTimePatternGenerator &amp;other) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UBool DateTimePatternGenerator::operator==(const DateTimePatternGenerator &amp;other) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>void DateTimePatternGenerator::setAppendItemFormat(UDateTimePatternField field, const UnicodeString &amp;value)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>static DateTimePatternGenerator* DateTimePatternGenerator::createInstance(const Locale &amp;uLocale, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>static DateTimePatternGenerator* DateTimePatternGenerator::createInstance(UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>static DateTimePatternGenerator* DateTimePatternGenerator::createEmptyInstance(UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>void DateTimePatternGenerator::setAppendItemName(UDateTimePatternField field, const UnicodeString &amp;value)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UDateTimePatternConflict DateTimePatternGenerator::addPattern(const UnicodeString &amp;pattern, UBool override, UnicodeString &amp;conflictingPattern, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UClassID DateTimePatternGenerator::getDynamicClassID() const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>const UnicodeString&amp; DateTimePatternGenerator::getDecimal() const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>DateTimePatternGenerator::~DateTimePatternGenerator()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UnicodeString DateTimePatternGenerator::getSkeleton(const UnicodeString &amp;pattern, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>StringEnumeration* DateTimePatternGenerator::getSkeletons(UErrorCode &amp;status) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>DateTimePatternGenerator* DateTimePatternGenerator::clone() const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UnicodeString DateTimePatternGenerator::replaceFieldTypes(const UnicodeString &amp;pattern, const UnicodeString &amp;skeleton, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>const UnicodeString&amp; DateTimePatternGenerator::getAppendItemFormat(UDateTimePatternField field) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>const UnicodeString&amp; DateTimePatternGenerator::getAppendItemName(UDateTimePatternField field) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>static UClassID DateTimePatternGenerator::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UnicodeString DateTimePatternGenerator::getBaseSkeleton(const UnicodeString &amp;pattern, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>StringEnumeration* DateTimePatternGenerator::getBaseSkeletons(UErrorCode &amp;status) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateTimeRule::DateTimeRule(int32_t month, int32_t weekInMonth, int32_t dayOfWeek, int32_t millisInDay, TimeRuleType timeType)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>int32_t DateTimeRule::getRuleWeekInMonth(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>UBool DateTimeRule::operator==(const DateTimeRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>int32_t DateTimeRule::getRuleMonth(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateTimeRule* DateTimeRule::clone(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>TimeRuleType DateTimeRule::getTimeRuleType(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateTimeRule::DateTimeRule(int32_t month, int32_t dayOfMonth, int32_t millisInDay, TimeRuleType timeType)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>UBool DateTimeRule::operator!=(const DateTimeRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateTimeRule&amp; DateTimeRule::operator=(const DateTimeRule &amp;right)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateTimeRule::DateTimeRule(const DateTimeRule &amp;source)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>UClassID DateTimeRule::getDynamicClassID(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>int32_t DateTimeRule::getRuleMillisInDay(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>static UClassID DateTimeRule::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>int32_t DateTimeRule::getRuleDayOfWeek(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateRuleType DateTimeRule::getDateRuleType(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>int32_t DateTimeRule::getRuleDayOfMonth(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateTimeRule::DateTimeRule(int32_t month, int32_t dayOfMonth, int32_t dayOfWeek, UBool after, int32_t millisInDay, TimeRuleType timeType)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateTimeRule::~DateTimeRule()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>UBool RuleBasedTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>RuleBasedTimeZone::RuleBasedTimeZone(const UnicodeString &amp;id, InitialTimeZoneRule *initialRule)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>RuleBasedTimeZone::RuleBasedTimeZone(const RuleBasedTimeZone &amp;source)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>int32_t RuleBasedTimeZone::getRawOffset(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>static UClassID RuleBasedTimeZone::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>void RuleBasedTimeZone::complete(UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>RuleBasedTimeZone&amp; RuleBasedTimeZone::operator=(const RuleBasedTimeZone &amp;right)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>TimeZone* RuleBasedTimeZone::clone(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>void RuleBasedTimeZone::getOffset(UDate date, UBool local, int32_t &amp;rawOffset, int32_t &amp;dstOffset, UErrorCode &amp;ec) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>RuleBasedTimeZone::~RuleBasedTimeZone()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>UBool RuleBasedTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>UBool RuleBasedTimeZone::operator!=(const TimeZone &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>int32_t RuleBasedTimeZone::getOffset(uint8_t era, int32_t year, int32_t month, int32_t day, uint8_t dayOfWeek, int32_t millis, int32_t monthLength, UErrorCode &amp;status) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>int32_t RuleBasedTimeZone::countTransitionRules(UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>UBool RuleBasedTimeZone::operator==(const TimeZone &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>UBool RuleBasedTimeZone::useDaylightTime(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>UClassID RuleBasedTimeZone::getDynamicClassID(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>int32_t RuleBasedTimeZone::getOffset(uint8_t era, int32_t year, int32_t month, int32_t day, uint8_t dayOfWeek, int32_t millis, UErrorCode &amp;status) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>void RuleBasedTimeZone::getTimeZoneRules(const InitialTimeZoneRule *&amp;initial, const TimeZoneRule *trsrules[], int32_t &amp;trscount, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>UBool RuleBasedTimeZone::hasSameRules(const TimeZone &amp;other) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>void RuleBasedTimeZone::addTransitionRule(TimeZoneRule *rule, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>void RuleBasedTimeZone::setRawOffset(int32_t offsetMillis)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>simpletz.h</td><td>void SimpleTimeZone::getTimeZoneRules(const InitialTimeZoneRule *&amp;initial, const TimeZoneRule *trsrules[], int32_t &amp;trscount, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>simpletz.h</td><td>UBool SimpleTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>simpletz.h</td><td>int32_t SimpleTimeZone::countTransitionRules(UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>simpletz.h</td><td>UBool SimpleTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>timezone.h</td><td>static const char* TimeZone::getTZDataVersion(UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeZoneRule::operator!=(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeZoneRule::operator==(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UClassID AnnualTimeZoneRule::getDynamicClassID(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::getStartInYear(int32_t year, int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>AnnualTimeZoneRule::AnnualTimeZoneRule(const AnnualTimeZoneRule &amp;source)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::isEquivalentTo(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>AnnualTimeZoneRule::~AnnualTimeZoneRule()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::operator==(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>static UClassID TimeArrayTimeZoneRule::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::getFinalStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UClassID InitialTimeZoneRule::getDynamicClassID(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::operator!=(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::isEquivalentTo(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::getStartTimeAt(int32_t index, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>const DateTimeRule* AnnualTimeZoneRule::getRule(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>AnnualTimeZoneRule::AnnualTimeZoneRule(const UnicodeString &amp;name, int32_t rawOffset, int32_t dstSavings, const DateTimeRule &amp;dateTimeRule, int32_t startYear, int32_t endYear)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>TimeArrayTimeZoneRule&amp; TimeArrayTimeZoneRule::operator=(const TimeArrayTimeZoneRule &amp;right)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::getFirstStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>static UClassID AnnualTimeZoneRule::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::operator!=(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeZoneRule::getPreviousStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const =0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>TimeZoneRule* TimeZoneRule::clone(void) const =0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeZoneRule::getNextStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const =0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>InitialTimeZoneRule&amp; InitialTimeZoneRule::operator=(const InitialTimeZoneRule &amp;right)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>TimeArrayTimeZoneRule* TimeArrayTimeZoneRule::clone(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>int32_t TimeZoneRule::getDSTSavings(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UClassID TimeArrayTimeZoneRule::getDynamicClassID(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>int32_t AnnualTimeZoneRule::getStartYear(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::getNextStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::getFinalStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>AnnualTimeZoneRule&amp; AnnualTimeZoneRule::operator=(const AnnualTimeZoneRule &amp;right)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>int32_t TimeZoneRule::getRawOffset(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>TimeArrayTimeZoneRule::TimeArrayTimeZoneRule(const UnicodeString &amp;name, int32_t rawOffset, int32_t dstSavings, const UDate *startTimes, int32_t numStartTimes, DateTimeRule::TimeRuleType timeRuleType)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>TimeArrayTimeZoneRule::~TimeArrayTimeZoneRule()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::operator==(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>int32_t TimeArrayTimeZoneRule::countStartTimes(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>InitialTimeZoneRule::InitialTimeZoneRule(const InitialTimeZoneRule &amp;source)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeZoneRule::isEquivalentTo(const TimeZoneRule &amp;other) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::getPreviousStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>InitialTimeZoneRule::InitialTimeZoneRule(const UnicodeString &amp;name, int32_t rawOffset, int32_t dstSavings)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>int32_t AnnualTimeZoneRule::getEndYear(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::getFirstStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>TimeZoneRule::~TimeZoneRule()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>InitialTimeZoneRule* InitialTimeZoneRule::clone(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::getPreviousStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeZoneRule::getFinalStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const =0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::getNextStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::operator!=(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>InitialTimeZoneRule::~InitialTimeZoneRule()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::getStartInYear(int32_t year, int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>TimeArrayTimeZoneRule::TimeArrayTimeZoneRule(const TimeArrayTimeZoneRule &amp;source)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::operator==(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::getNextStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UnicodeString&amp; TimeZoneRule::getName(UnicodeString &amp;name) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>AnnualTimeZoneRule::AnnualTimeZoneRule(const UnicodeString &amp;name, int32_t rawOffset, int32_t dstSavings, DateTimeRule *dateTimeRule, int32_t startYear, int32_t endYear)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>static UClassID InitialTimeZoneRule::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::getPreviousStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::getFirstStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeZoneRule::getFirstStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const =0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>AnnualTimeZoneRule* AnnualTimeZoneRule::clone(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>DateTimeRule::TimeRuleType TimeArrayTimeZoneRule::getTimeType(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::isEquivalentTo(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::getFinalStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>TimeZoneTransition::~TimeZoneTransition()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>UClassID TimeZoneTransition::getDynamicClassID(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>UBool TimeZoneTransition::operator==(const TimeZoneTransition &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>UDate TimeZoneTransition::getTime(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>void TimeZoneTransition::setFrom(const TimeZoneRule &amp;from)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>TimeZoneTransition* TimeZoneTransition::clone(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>void TimeZoneTransition::setTime(UDate time)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>TimeZoneTransition::TimeZoneTransition()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>void TimeZoneTransition::adoptTo(TimeZoneRule *to)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>const TimeZoneRule* TimeZoneTransition::getFrom(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>UBool TimeZoneTransition::operator!=(const TimeZoneTransition &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>TimeZoneTransition::TimeZoneTransition(UDate time, const TimeZoneRule &amp;from, const TimeZoneRule &amp;to)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>void TimeZoneTransition::adoptFrom(TimeZoneRule *from)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>TimeZoneTransition::TimeZoneTransition(const TimeZoneTransition &amp;source)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>TimeZoneTransition&amp; TimeZoneTransition::operator=(const TimeZoneTransition &amp;right)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>void TimeZoneTransition::setTo(const TimeZoneRule &amp;to)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>static UClassID TimeZoneTransition::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>const TimeZoneRule* TimeZoneTransition::getTo(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>ucal.h</td><td>const char* ucal_getTZDataVersion(UErrorCode *status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>ucasemap.h</td><td>int32_t ucasemap_utf8ToTitle(UCaseMap *csm, char *dest, int32_t destCapacity, const char *src, int32_t srcLength, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>ucasemap.h</td><td>int32_t ucasemap_utf8FoldCase(const UCaseMap *csm, char *dest, int32_t destCapacity, const char *src, int32_t srcLength, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>ucasemap.h</td><td>int32_t ucasemap_toTitle(UCaseMap *csm, UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>ucasemap.h</td><td>void ucasemap_setBreakIterator(UCaseMap *csm, UBreakIterator *iterToAdopt, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>ucasemap.h</td><td>const UBreakIterator* ucasemap_getBreakIterator(const UCaseMap *csm)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>int32_t udatpg_getBaseSkeleton(UDateTimePatternGenerator *dtpg, const UChar *pattern, int32_t length, UChar *baseSkeleton, int32_t capacity, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>const UChar* udatpg_getDateTimeFormat(const UDateTimePatternGenerator *dtpg, int32_t *pLength)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>void udatpg_setAppendItemName(UDateTimePatternGenerator *dtpg, UDateTimePatternField field, const UChar *value, int32_t length)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>const UChar* udatpg_getPatternForSkeleton(const UDateTimePatternGenerator *dtpg, const UChar *skeleton, int32_t skeletonLength, int32_t *pLength)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>void udatpg_setAppendItemFormat(UDateTimePatternGenerator *dtpg, UDateTimePatternField field, const UChar *value, int32_t length)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>int32_t udatpg_replaceFieldTypes(UDateTimePatternGenerator *dtpg, const UChar *pattern, int32_t patternLength, const UChar *skeleton, int32_t skeletonLength, UChar *dest, int32_t destCapacity, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>int32_t udatpg_getBestPattern(UDateTimePatternGenerator *dtpg, const UChar *skeleton, int32_t length, UChar *bestPattern, int32_t capacity, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>UDateTimePatternGenerator* udatpg_open(const char *locale, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>UDateTimePatternGenerator* udatpg_openEmpty(UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>UDateTimePatternConflict udatpg_addPattern(UDateTimePatternGenerator *dtpg, const UChar *pattern, int32_t patternLength, UBool override, UChar *conflictingPattern, int32_t capacity, int32_t *pLength, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>int32_t udatpg_getSkeleton(UDateTimePatternGenerator *dtpg, const UChar *pattern, int32_t length, UChar *skeleton, int32_t capacity, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>void udatpg_close(UDateTimePatternGenerator *dtpg)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>const UChar* udatpg_getAppendItemFormat(const UDateTimePatternGenerator *dtpg, UDateTimePatternField field, int32_t *pLength)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>const UChar* udatpg_getAppendItemName(const UDateTimePatternGenerator *dtpg, UDateTimePatternField field, int32_t *pLength)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>void udatpg_setDateTimeFormat(const UDateTimePatternGenerator *dtpg, const UChar *dtFormat, int32_t length)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>UEnumeration* udatpg_openBaseSkeletons(const UDateTimePatternGenerator *dtpg, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>const UChar* udatpg_getDecimal(const UDateTimePatternGenerator *dtpg, int32_t *pLength)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>void udatpg_setDecimal(UDateTimePatternGenerator *dtpg, const UChar *decimal, int32_t length)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>UEnumeration* udatpg_openSkeletons(const UDateTimePatternGenerator *dtpg, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>UDateTimePatternGenerator* udatpg_clone(const UDateTimePatternGenerator *dtpg, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uloc.h</td><td>int32_t uloc_getLocaleForLCID(uint32_t hostID, char *locale, int32_t localeCapacity, UErrorCode *status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>int32_t UnicodeSet::spanBack(const UChar *s, int32_t length, USetSpanCondition spanCondition) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>UBool UnicodeSet::isFrozen() const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>int32_t UnicodeSet::spanUTF8(const char *s, int32_t length, USetSpanCondition spanCondition) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>UnicodeFunctor* UnicodeSet::freeze()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>UnicodeFunctor* UnicodeSet::cloneAsThawed() const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>int32_t UnicodeSet::spanBackUTF8(const char *s, int32_t length, USetSpanCondition spanCondition) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>int32_t UnicodeSet::span(const UChar *s, int32_t length, USetSpanCondition spanCondition) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>unistr.h</td><td>UnicodeString&amp; UnicodeString::toTitle(BreakIterator *titleIter, const Locale &amp;locale, uint32_t options)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="color: red">
<td>unistr.h</td><td>int32_t u_strlen(const UChar *s)</td><td>Stable</td><td></td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>int32_t uset_spanUTF8(const USet *set, const char *s, int32_t length, USetSpanCondition spanCondition)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>int32_t uset_span(const USet *set, const UChar *s, int32_t length, USetSpanCondition spanCondition)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>USet* uset_cloneAsThawed(const USet *set)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>void uset_freeze(USet *set)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>USet* uset_clone(const USet *set)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>int32_t uset_spanBack(const USet *set, const UChar *s, int32_t length, USetSpanCondition spanCondition)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>UBool uset_isFrozen(const USet *set)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>int32_t uset_spanBackUTF8(const USet *set, const char *s, int32_t length, USetSpanCondition spanCondition)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::getLastModified(UDate &amp;lastModified) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>static VTimeZone* VTimeZone::createVTimeZoneByID(const UnicodeString &amp;ID)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::getTimeZoneRules(const InitialTimeZoneRule *&amp;initial, const TimeZoneRule *trsrules[], int32_t &amp;trscount, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::getOffset(UDate date, UBool local, int32_t &amp;rawOffset, int32_t &amp;dstOffset, UErrorCode &amp;ec) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>VTimeZone::VTimeZone(const VTimeZone &amp;source)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>int32_t VTimeZone::getOffset(uint8_t era, int32_t year, int32_t month, int32_t day, uint8_t dayOfWeek, int32_t millis, int32_t monthLength, UErrorCode &amp;status) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::setTZURL(const UnicodeString &amp;url)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UClassID VTimeZone::getDynamicClassID(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>int32_t VTimeZone::getRawOffset(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::write(UnicodeString &amp;result, UErrorCode &amp;status) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::operator!=(const TimeZone &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>int32_t VTimeZone::countTransitionRules(UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>TimeZone* VTimeZone::clone(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>VTimeZone&amp; VTimeZone::operator=(const VTimeZone &amp;right)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>VTimeZone::~VTimeZone()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::write(UDate start, UnicodeString &amp;result, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::setLastModified(UDate lastModified)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>int32_t VTimeZone::getOffset(uint8_t era, int32_t year, int32_t month, int32_t day, uint8_t dayOfWeek, int32_t millis, UErrorCode &amp;status) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>static VTimeZone* VTimeZone::createVTimeZone(const UnicodeString &amp;vtzdata, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::hasSameRules(const TimeZone &amp;other) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::setRawOffset(int32_t offsetMillis)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::getTZURL(UnicodeString &amp;url) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>static UClassID VTimeZone::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::operator==(const TimeZone &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::useDaylightTime(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::writeSimple(UDate time, UnicodeString &amp;result, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
</table>
<P></P>
<hr>
<h2>Promoted to stable in ICU 4.0</h2>
<table BORDER="1">
<THEAD>
<tr>
<th>File</th><th>Public API Prototype</th><th>ICU 3.8.1</th><th>ICU 4.0</th>
</tr>
</THEAD>
<tr STYLE="">
<td>basictz.h</td><td>BasicTimeZone::~BasicTimeZone()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>basictz.h</td><td>UBool BasicTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)=0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>basictz.h</td><td>int32_t BasicTimeZone::countTransitionRules(UErrorCode &amp;status)=0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>basictz.h</td><td>UBool BasicTimeZone::hasEquivalentTransitions(BasicTimeZone &amp;tz, UDate start, UDate end, UBool ignoreDstAmount, UErrorCode &amp;ec)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>basictz.h</td><td>void BasicTimeZone::getTimeZoneRules(const InitialTimeZoneRule *&amp;initial, const TimeZoneRule *trsrules[], int32_t &amp;trscount, UErrorCode &amp;status)=0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>basictz.h</td><td>UBool BasicTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)=0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>basictz.h</td><td>void BasicTimeZone::getSimpleRulesNear(UDate date, InitialTimeZoneRule *&amp;initial, AnnualTimeZoneRule *&amp;std, AnnualTimeZoneRule *&amp;dst, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>UBool DateIntervalInfo::operator==(const DateIntervalInfo &amp;other) const</td><td>None</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>UBool DateIntervalInfo::operator!=(const DateIntervalInfo &amp;other) const</td><td>None</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>static UClassID DateIntervalInfo::getStaticClassID()</td><td>None</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>UClassID DateIntervalInfo::getDynamicClassID() const</td><td>None</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>const UnicodeString&amp; DateTimePatternGenerator::getDateTimeFormat() const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>void DateTimePatternGenerator::setDecimal(const UnicodeString &amp;decimal)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>const UnicodeString&amp; DateTimePatternGenerator::getPatternForSkeleton(const UnicodeString &amp;skeleton) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UnicodeString DateTimePatternGenerator::getBestPattern(const UnicodeString &amp;skeleton, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>void DateTimePatternGenerator::setDateTimeFormat(const UnicodeString &amp;dateTimeFormat)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UBool DateTimePatternGenerator::operator!=(const DateTimePatternGenerator &amp;other) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UBool DateTimePatternGenerator::operator==(const DateTimePatternGenerator &amp;other) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>void DateTimePatternGenerator::setAppendItemFormat(UDateTimePatternField field, const UnicodeString &amp;value)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>static DateTimePatternGenerator* DateTimePatternGenerator::createInstance(const Locale &amp;uLocale, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>static DateTimePatternGenerator* DateTimePatternGenerator::createInstance(UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>static DateTimePatternGenerator* DateTimePatternGenerator::createEmptyInstance(UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>void DateTimePatternGenerator::setAppendItemName(UDateTimePatternField field, const UnicodeString &amp;value)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UDateTimePatternConflict DateTimePatternGenerator::addPattern(const UnicodeString &amp;pattern, UBool override, UnicodeString &amp;conflictingPattern, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UClassID DateTimePatternGenerator::getDynamicClassID() const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>const UnicodeString&amp; DateTimePatternGenerator::getDecimal() const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>DateTimePatternGenerator::~DateTimePatternGenerator()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UnicodeString DateTimePatternGenerator::getSkeleton(const UnicodeString &amp;pattern, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>StringEnumeration* DateTimePatternGenerator::getSkeletons(UErrorCode &amp;status) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>DateTimePatternGenerator* DateTimePatternGenerator::clone() const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UnicodeString DateTimePatternGenerator::replaceFieldTypes(const UnicodeString &amp;pattern, const UnicodeString &amp;skeleton, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>const UnicodeString&amp; DateTimePatternGenerator::getAppendItemFormat(UDateTimePatternField field) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>const UnicodeString&amp; DateTimePatternGenerator::getAppendItemName(UDateTimePatternField field) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>static UClassID DateTimePatternGenerator::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>UnicodeString DateTimePatternGenerator::getBaseSkeleton(const UnicodeString &amp;pattern, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtptngen.h</td><td>StringEnumeration* DateTimePatternGenerator::getBaseSkeletons(UErrorCode &amp;status) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateTimeRule::DateTimeRule(int32_t month, int32_t weekInMonth, int32_t dayOfWeek, int32_t millisInDay, TimeRuleType timeType)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>int32_t DateTimeRule::getRuleWeekInMonth(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>UBool DateTimeRule::operator==(const DateTimeRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>int32_t DateTimeRule::getRuleMonth(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateTimeRule* DateTimeRule::clone(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>TimeRuleType DateTimeRule::getTimeRuleType(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateTimeRule::DateTimeRule(int32_t month, int32_t dayOfMonth, int32_t millisInDay, TimeRuleType timeType)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>UBool DateTimeRule::operator!=(const DateTimeRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateTimeRule&amp; DateTimeRule::operator=(const DateTimeRule &amp;right)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateTimeRule::DateTimeRule(const DateTimeRule &amp;source)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>UClassID DateTimeRule::getDynamicClassID(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>int32_t DateTimeRule::getRuleMillisInDay(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>static UClassID DateTimeRule::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>int32_t DateTimeRule::getRuleDayOfWeek(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateRuleType DateTimeRule::getDateRuleType(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>int32_t DateTimeRule::getRuleDayOfMonth(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateTimeRule::DateTimeRule(int32_t month, int32_t dayOfMonth, int32_t dayOfWeek, UBool after, int32_t millisInDay, TimeRuleType timeType)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtrule.h</td><td>DateTimeRule::~DateTimeRule()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>LESwaps.h</td><td>static le_uint16 LESwaps::swapWord(const le_uint16 &amp;value)</td><td>None</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>LESwaps.h</td><td>static le_uint32 LESwaps::swapLong(const le_uint32 &amp;value)</td><td>None</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>msgfmt.h</td><td>UnicodeString&amp; MessageFormat::format(const UnicodeString *argumentNames, const Formattable *arguments, int32_t count, UnicodeString &amp;appendTo, UErrorCode &amp;status) const</td><td>None</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>UBool RuleBasedTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>RuleBasedTimeZone::RuleBasedTimeZone(const UnicodeString &amp;id, InitialTimeZoneRule *initialRule)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>RuleBasedTimeZone::RuleBasedTimeZone(const RuleBasedTimeZone &amp;source)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>int32_t RuleBasedTimeZone::getRawOffset(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>static UClassID RuleBasedTimeZone::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>void RuleBasedTimeZone::complete(UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>RuleBasedTimeZone&amp; RuleBasedTimeZone::operator=(const RuleBasedTimeZone &amp;right)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>TimeZone* RuleBasedTimeZone::clone(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>void RuleBasedTimeZone::getOffset(UDate date, UBool local, int32_t &amp;rawOffset, int32_t &amp;dstOffset, UErrorCode &amp;ec) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>RuleBasedTimeZone::~RuleBasedTimeZone()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>UBool RuleBasedTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>UBool RuleBasedTimeZone::operator!=(const TimeZone &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>int32_t RuleBasedTimeZone::getOffset(uint8_t era, int32_t year, int32_t month, int32_t day, uint8_t dayOfWeek, int32_t millis, int32_t monthLength, UErrorCode &amp;status) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>int32_t RuleBasedTimeZone::countTransitionRules(UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>UBool RuleBasedTimeZone::operator==(const TimeZone &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>UBool RuleBasedTimeZone::useDaylightTime(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>UClassID RuleBasedTimeZone::getDynamicClassID(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>int32_t RuleBasedTimeZone::getOffset(uint8_t era, int32_t year, int32_t month, int32_t day, uint8_t dayOfWeek, int32_t millis, UErrorCode &amp;status) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>void RuleBasedTimeZone::getTimeZoneRules(const InitialTimeZoneRule *&amp;initial, const TimeZoneRule *trsrules[], int32_t &amp;trscount, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>UBool RuleBasedTimeZone::hasSameRules(const TimeZone &amp;other) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>void RuleBasedTimeZone::addTransitionRule(TimeZoneRule *rule, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>rbtz.h</td><td>void RuleBasedTimeZone::setRawOffset(int32_t offsetMillis)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>simpletz.h</td><td>void SimpleTimeZone::getTimeZoneRules(const InitialTimeZoneRule *&amp;initial, const TimeZoneRule *trsrules[], int32_t &amp;trscount, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>simpletz.h</td><td>UBool SimpleTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>simpletz.h</td><td>int32_t SimpleTimeZone::countTransitionRules(UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>simpletz.h</td><td>UBool SimpleTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>timezone.h</td><td>static const char* TimeZone::getTZDataVersion(UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeZoneRule::operator!=(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeZoneRule::operator==(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UClassID AnnualTimeZoneRule::getDynamicClassID(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::getStartInYear(int32_t year, int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>AnnualTimeZoneRule::AnnualTimeZoneRule(const AnnualTimeZoneRule &amp;source)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::isEquivalentTo(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>AnnualTimeZoneRule::~AnnualTimeZoneRule()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::operator==(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>static UClassID TimeArrayTimeZoneRule::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::getFinalStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UClassID InitialTimeZoneRule::getDynamicClassID(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::operator!=(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::isEquivalentTo(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::getStartTimeAt(int32_t index, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>const DateTimeRule* AnnualTimeZoneRule::getRule(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>AnnualTimeZoneRule::AnnualTimeZoneRule(const UnicodeString &amp;name, int32_t rawOffset, int32_t dstSavings, const DateTimeRule &amp;dateTimeRule, int32_t startYear, int32_t endYear)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>TimeArrayTimeZoneRule&amp; TimeArrayTimeZoneRule::operator=(const TimeArrayTimeZoneRule &amp;right)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::getFirstStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>static UClassID AnnualTimeZoneRule::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::operator!=(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeZoneRule::getPreviousStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const =0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>TimeZoneRule* TimeZoneRule::clone(void) const =0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeZoneRule::getNextStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const =0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>InitialTimeZoneRule&amp; InitialTimeZoneRule::operator=(const InitialTimeZoneRule &amp;right)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>TimeArrayTimeZoneRule* TimeArrayTimeZoneRule::clone(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>int32_t TimeZoneRule::getDSTSavings(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UClassID TimeArrayTimeZoneRule::getDynamicClassID(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>int32_t AnnualTimeZoneRule::getStartYear(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::getNextStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::getFinalStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>AnnualTimeZoneRule&amp; AnnualTimeZoneRule::operator=(const AnnualTimeZoneRule &amp;right)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>int32_t TimeZoneRule::getRawOffset(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>TimeArrayTimeZoneRule::TimeArrayTimeZoneRule(const UnicodeString &amp;name, int32_t rawOffset, int32_t dstSavings, const UDate *startTimes, int32_t numStartTimes, DateTimeRule::TimeRuleType timeRuleType)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>TimeArrayTimeZoneRule::~TimeArrayTimeZoneRule()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::operator==(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>int32_t TimeArrayTimeZoneRule::countStartTimes(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>InitialTimeZoneRule::InitialTimeZoneRule(const InitialTimeZoneRule &amp;source)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeZoneRule::isEquivalentTo(const TimeZoneRule &amp;other) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::getPreviousStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>InitialTimeZoneRule::InitialTimeZoneRule(const UnicodeString &amp;name, int32_t rawOffset, int32_t dstSavings)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>int32_t AnnualTimeZoneRule::getEndYear(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::getFirstStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>TimeZoneRule::~TimeZoneRule()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>InitialTimeZoneRule* InitialTimeZoneRule::clone(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::getPreviousStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeZoneRule::getFinalStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const =0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::getNextStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::operator!=(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>InitialTimeZoneRule::~InitialTimeZoneRule()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::getStartInYear(int32_t year, int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>TimeArrayTimeZoneRule::TimeArrayTimeZoneRule(const TimeArrayTimeZoneRule &amp;source)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeArrayTimeZoneRule::operator==(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::getNextStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UnicodeString&amp; TimeZoneRule::getName(UnicodeString &amp;name) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>AnnualTimeZoneRule::AnnualTimeZoneRule(const UnicodeString &amp;name, int32_t rawOffset, int32_t dstSavings, DateTimeRule *dateTimeRule, int32_t startYear, int32_t endYear)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>static UClassID InitialTimeZoneRule::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::getPreviousStart(UDate base, int32_t prevRawOffset, int32_t prevDSTSavings, UBool inclusive, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::getFirstStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool TimeZoneRule::getFirstStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const =0</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>AnnualTimeZoneRule* AnnualTimeZoneRule::clone(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>DateTimeRule::TimeRuleType TimeArrayTimeZoneRule::getTimeType(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool AnnualTimeZoneRule::isEquivalentTo(const TimeZoneRule &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tzrule.h</td><td>UBool InitialTimeZoneRule::getFinalStart(int32_t prevRawOffset, int32_t prevDSTSavings, UDate &amp;result) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>TimeZoneTransition::~TimeZoneTransition()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>UClassID TimeZoneTransition::getDynamicClassID(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>UBool TimeZoneTransition::operator==(const TimeZoneTransition &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>UDate TimeZoneTransition::getTime(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>void TimeZoneTransition::setFrom(const TimeZoneRule &amp;from)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>TimeZoneTransition* TimeZoneTransition::clone(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>void TimeZoneTransition::setTime(UDate time)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>TimeZoneTransition::TimeZoneTransition()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>void TimeZoneTransition::adoptTo(TimeZoneRule *to)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>const TimeZoneRule* TimeZoneTransition::getFrom(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>UBool TimeZoneTransition::operator!=(const TimeZoneTransition &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>TimeZoneTransition::TimeZoneTransition(UDate time, const TimeZoneRule &amp;from, const TimeZoneRule &amp;to)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>void TimeZoneTransition::adoptFrom(TimeZoneRule *from)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>TimeZoneTransition::TimeZoneTransition(const TimeZoneTransition &amp;source)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>TimeZoneTransition&amp; TimeZoneTransition::operator=(const TimeZoneTransition &amp;right)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>void TimeZoneTransition::setTo(const TimeZoneRule &amp;to)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>static UClassID TimeZoneTransition::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>tztrans.h</td><td>const TimeZoneRule* TimeZoneTransition::getTo(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>ucal.h</td><td>const char* ucal_getTZDataVersion(UErrorCode *status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>ucasemap.h</td><td>int32_t ucasemap_utf8ToTitle(UCaseMap *csm, char *dest, int32_t destCapacity, const char *src, int32_t srcLength, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>ucasemap.h</td><td>int32_t ucasemap_utf8FoldCase(const UCaseMap *csm, char *dest, int32_t destCapacity, const char *src, int32_t srcLength, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>ucasemap.h</td><td>int32_t ucasemap_toTitle(UCaseMap *csm, UChar *dest, int32_t destCapacity, const UChar *src, int32_t srcLength, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>ucasemap.h</td><td>void ucasemap_setBreakIterator(UCaseMap *csm, UBreakIterator *iterToAdopt, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>ucasemap.h</td><td>const UBreakIterator* ucasemap_getBreakIterator(const UCaseMap *csm)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>int32_t udatpg_getBaseSkeleton(UDateTimePatternGenerator *dtpg, const UChar *pattern, int32_t length, UChar *baseSkeleton, int32_t capacity, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>const UChar* udatpg_getDateTimeFormat(const UDateTimePatternGenerator *dtpg, int32_t *pLength)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>void udatpg_setAppendItemName(UDateTimePatternGenerator *dtpg, UDateTimePatternField field, const UChar *value, int32_t length)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>const UChar* udatpg_getPatternForSkeleton(const UDateTimePatternGenerator *dtpg, const UChar *skeleton, int32_t skeletonLength, int32_t *pLength)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>void udatpg_setAppendItemFormat(UDateTimePatternGenerator *dtpg, UDateTimePatternField field, const UChar *value, int32_t length)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>int32_t udatpg_replaceFieldTypes(UDateTimePatternGenerator *dtpg, const UChar *pattern, int32_t patternLength, const UChar *skeleton, int32_t skeletonLength, UChar *dest, int32_t destCapacity, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>int32_t udatpg_getBestPattern(UDateTimePatternGenerator *dtpg, const UChar *skeleton, int32_t length, UChar *bestPattern, int32_t capacity, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>UDateTimePatternGenerator* udatpg_open(const char *locale, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>UDateTimePatternGenerator* udatpg_openEmpty(UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>UDateTimePatternConflict udatpg_addPattern(UDateTimePatternGenerator *dtpg, const UChar *pattern, int32_t patternLength, UBool override, UChar *conflictingPattern, int32_t capacity, int32_t *pLength, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>int32_t udatpg_getSkeleton(UDateTimePatternGenerator *dtpg, const UChar *pattern, int32_t length, UChar *skeleton, int32_t capacity, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>void udatpg_close(UDateTimePatternGenerator *dtpg)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>const UChar* udatpg_getAppendItemFormat(const UDateTimePatternGenerator *dtpg, UDateTimePatternField field, int32_t *pLength)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>const UChar* udatpg_getAppendItemName(const UDateTimePatternGenerator *dtpg, UDateTimePatternField field, int32_t *pLength)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>void udatpg_setDateTimeFormat(const UDateTimePatternGenerator *dtpg, const UChar *dtFormat, int32_t length)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>UEnumeration* udatpg_openBaseSkeletons(const UDateTimePatternGenerator *dtpg, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>const UChar* udatpg_getDecimal(const UDateTimePatternGenerator *dtpg, int32_t *pLength)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>void udatpg_setDecimal(UDateTimePatternGenerator *dtpg, const UChar *decimal, int32_t length)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>UEnumeration* udatpg_openSkeletons(const UDateTimePatternGenerator *dtpg, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>udatpg.h</td><td>UDateTimePatternGenerator* udatpg_clone(const UDateTimePatternGenerator *dtpg, UErrorCode *pErrorCode)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uloc.h</td><td>int32_t uloc_getLocaleForLCID(uint32_t hostID, char *locale, int32_t localeCapacity, UErrorCode *status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>int32_t UnicodeSet::spanBack(const UChar *s, int32_t length, USetSpanCondition spanCondition) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>UBool UnicodeSet::isFrozen() const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>int32_t UnicodeSet::spanUTF8(const char *s, int32_t length, USetSpanCondition spanCondition) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>UnicodeFunctor* UnicodeSet::freeze()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>UnicodeFunctor* UnicodeSet::cloneAsThawed() const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>int32_t UnicodeSet::spanBackUTF8(const char *s, int32_t length, USetSpanCondition spanCondition) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>int32_t UnicodeSet::span(const UChar *s, int32_t length, USetSpanCondition spanCondition) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>unistr.h</td><td>UnicodeString&amp; UnicodeString::toTitle(BreakIterator *titleIter, const Locale &amp;locale, uint32_t options)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>int32_t uset_spanUTF8(const USet *set, const char *s, int32_t length, USetSpanCondition spanCondition)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>int32_t uset_span(const USet *set, const UChar *s, int32_t length, USetSpanCondition spanCondition)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>USet* uset_cloneAsThawed(const USet *set)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>void uset_freeze(USet *set)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>USet* uset_clone(const USet *set)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>int32_t uset_spanBack(const USet *set, const UChar *s, int32_t length, USetSpanCondition spanCondition)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>UBool uset_isFrozen(const USet *set)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>uset.h</td><td>int32_t uset_spanBackUTF8(const USet *set, const char *s, int32_t length, USetSpanCondition spanCondition)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::getLastModified(UDate &amp;lastModified) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>static VTimeZone* VTimeZone::createVTimeZoneByID(const UnicodeString &amp;ID)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::getTimeZoneRules(const InitialTimeZoneRule *&amp;initial, const TimeZoneRule *trsrules[], int32_t &amp;trscount, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::getOffset(UDate date, UBool local, int32_t &amp;rawOffset, int32_t &amp;dstOffset, UErrorCode &amp;ec) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>VTimeZone::VTimeZone(const VTimeZone &amp;source)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>int32_t VTimeZone::getOffset(uint8_t era, int32_t year, int32_t month, int32_t day, uint8_t dayOfWeek, int32_t millis, int32_t monthLength, UErrorCode &amp;status) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::setTZURL(const UnicodeString &amp;url)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UClassID VTimeZone::getDynamicClassID(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>int32_t VTimeZone::getRawOffset(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::write(UnicodeString &amp;result, UErrorCode &amp;status) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::operator!=(const TimeZone &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>int32_t VTimeZone::countTransitionRules(UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>TimeZone* VTimeZone::clone(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>VTimeZone&amp; VTimeZone::operator=(const VTimeZone &amp;right)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>VTimeZone::~VTimeZone()</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::write(UDate start, UnicodeString &amp;result, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::setLastModified(UDate lastModified)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>int32_t VTimeZone::getOffset(uint8_t era, int32_t year, int32_t month, int32_t day, uint8_t dayOfWeek, int32_t millis, UErrorCode &amp;status) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>static VTimeZone* VTimeZone::createVTimeZone(const UnicodeString &amp;vtzdata, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::hasSameRules(const TimeZone &amp;other) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransition &amp;result)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::setRawOffset(int32_t offsetMillis)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::getTZURL(UnicodeString &amp;url) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>static UClassID VTimeZone::getStaticClassID(void)</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::operator==(const TimeZone &amp;that) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>UBool VTimeZone::useDaylightTime(void) const</td><td>Draft</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>vtzone.h</td><td>void VTimeZone::writeSimple(UDate time, UnicodeString &amp;result, UErrorCode &amp;status)</td><td>Draft</td><td>Stable</td>
</tr>
</table>
<P></P>
<hr>
<h2>Added in ICU 4.0</h2>
<table BORDER="1">
<THEAD>
<tr>
<th>File</th><th>Public API Prototype</th><th>ICU 3.8.1</th><th>ICU 4.0</th>
</tr>
</THEAD>
<tr STYLE="">
<td>datefmt.h</td><td>static DateFormat* DateFormat::createPatternInstance(const UnicodeString &amp;skeleton, const Locale &amp;locale, UErrorCode &amp;status)</td><td>None</td><td>Internal</td>
</tr>
<tr STYLE="">
<td>dtintrv.h</td><td>UClassID DateInterval::getDynamicClassID(void) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtintrv.h</td><td>UDate DateInterval::getFromDate() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtintrv.h</td><td>UBool DateInterval::operator!=(const DateInterval &amp;other) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtintrv.h</td><td>UBool DateInterval::operator==(const DateInterval &amp;other) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtintrv.h</td><td>DateInterval* DateInterval::clone() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtintrv.h</td><td>DateInterval::DateInterval(const DateInterval &amp;other)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtintrv.h</td><td>DateInterval::~DateInterval()</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtintrv.h</td><td>DateInterval&amp; DateInterval::operator=(const DateInterval &amp;)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtintrv.h</td><td>static UClassID DateInterval::getStaticClassID(void)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtintrv.h</td><td>DateInterval::DateInterval(UDate fromDate, UDate toDate)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtintrv.h</td><td>UDate DateInterval::getToDate() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>DateIntervalFormat::~DateIntervalFormat()</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>UnicodeString&amp; DateIntervalFormat::format(const DateInterval *dtInterval, UnicodeString &amp;appendTo, FieldPosition &amp;fieldPosition, UErrorCode &amp;status) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>void DateIntervalFormat::setDateIntervalInfo(const DateIntervalInfo &amp;newIntervalPatterns, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>UBool DateIntervalFormat::operator!=(const Format &amp;other) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>static DateIntervalFormat* DateIntervalFormat::createInstance(const UnicodeString &amp;skeleton, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>const DateIntervalInfo* DateIntervalFormat::getDateIntervalInfo(void) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>UBool DateIntervalFormat::operator==(const Format &amp;other) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>const DateFormat* DateIntervalFormat::getDateFormat(void) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>UnicodeString&amp; DateIntervalFormat::format(const Formattable &amp;obj, UnicodeString &amp;appendTo, FieldPosition &amp;fieldPosition, UErrorCode &amp;status) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>static DateIntervalFormat* DateIntervalFormat::createInstance(const UnicodeString &amp;skeleton, const Locale &amp;locale, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>static UClassID DateIntervalFormat::getStaticClassID(void)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>UnicodeString&amp; DateIntervalFormat::format(Calendar &amp;fromCalendar, Calendar &amp;toCalendar, UnicodeString &amp;appendTo, FieldPosition &amp;fieldPosition, UErrorCode &amp;status) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>static DateIntervalFormat* DateIntervalFormat::createInstance(const UnicodeString &amp;skeleton, const DateIntervalInfo &amp;dtitvinf, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>static DateIntervalFormat* DateIntervalFormat::createInstance(const UnicodeString &amp;skeleton, const Locale &amp;locale, const DateIntervalInfo &amp;dtitvinf, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>UClassID DateIntervalFormat::getDynamicClassID(void) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>Format* DateIntervalFormat::clone(void) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvfmt.h</td><td>void DateIntervalFormat::parseObject(const UnicodeString &amp;source, Formattable &amp;result, ParsePosition &amp;parse_pos) const</td><td>None</td><td>Internal</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>UBool DateIntervalInfo::operator==(const DateIntervalInfo &amp;other) const</td><td>None</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>UBool DateIntervalInfo::operator!=(const DateIntervalInfo &amp;other) const</td><td>None</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>DateIntervalInfo&amp; DateIntervalInfo::operator=(const DateIntervalInfo &amp;)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>UBool DateIntervalInfo::getDefaultOrder() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>DateIntervalInfo* DateIntervalInfo::clone(void) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>void DateIntervalInfo::setFallbackIntervalPattern(const UnicodeString &amp;fallbackPattern, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>DateIntervalInfo::~DateIntervalInfo()</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>static UClassID DateIntervalInfo::getStaticClassID()</td><td>None</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>DateIntervalInfo::DateIntervalInfo(const Locale &amp;locale, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>UnicodeString&amp; DateIntervalInfo::getFallbackIntervalPattern(UnicodeString &amp;result) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>UClassID DateIntervalInfo::getDynamicClassID() const</td><td>None</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>UnicodeString&amp; DateIntervalInfo::getIntervalPattern(const UnicodeString &amp;skeleton, UCalendarDateFields field, UnicodeString &amp;result, UErrorCode &amp;status) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>DateIntervalInfo::DateIntervalInfo(UErrorCode &amp;status)</td><td>None</td><td>Internal</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>U_NAMESPACE_BEGIN static U_CDECL_BEGIN UBool U_CALLCONV hashTableValueComparator(UHashTok val1, UHashTok val2)</td><td>None</td><td>Internal</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>DateIntervalInfo::DateIntervalInfo(const DateIntervalInfo &amp;)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>dtitvinf.h</td><td>void DateIntervalInfo::setIntervalPattern(const UnicodeString &amp;skeleton, UCalendarDateFields lrgDiffCalUnit, const UnicodeString &amp;intervalPattern, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>LESwaps.h</td><td>static le_uint16 LESwaps::swapWord(const le_uint16 &amp;value)</td><td>None</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>LESwaps.h</td><td>static le_uint32 LESwaps::swapLong(const le_uint32 &amp;value)</td><td>None</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>msgfmt.h</td><td>StringEnumeration* MessageFormat::getFormatNames(UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>msgfmt.h</td><td>void MessageFormat::adoptFormat(const UnicodeString &amp;formatName, Format *formatToAdopt, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>msgfmt.h</td><td>UnicodeString&amp; MessageFormat::format(const UnicodeString *argumentNames, const Formattable *arguments, int32_t count, UnicodeString &amp;appendTo, UErrorCode &amp;status) const</td><td>None</td><td>Stable</td>
</tr>
<tr STYLE="">
<td>msgfmt.h</td><td>UBool MessageFormat::usesNamedArguments() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>msgfmt.h</td><td>Format* MessageFormat::getFormat(const UnicodeString &amp;formatName, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>msgfmt.h</td><td>void MessageFormat::setFormat(const UnicodeString &amp;formatName, const Format &amp;format, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>UnicodeString&amp; PluralFormat::format(int32_t number, UnicodeString &amp;appendTo, FieldPosition &amp;pos, UErrorCode &amp;status) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>void PluralFormat::setNumberFormat(const NumberFormat *format, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>Format* PluralFormat::clone(void) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>void PluralFormat::setLocale(const Locale &amp;locale, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>PluralFormat::PluralFormat(const PluralRules &amp;rules, const UnicodeString &amp;pattern, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>UBool PluralFormat::operator==(const Format &amp;other) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>void PluralFormat::parseObject(const UnicodeString &amp;source, Formattable &amp;result, ParsePosition &amp;parse_pos) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>UnicodeString PluralFormat::format(int32_t number, UErrorCode &amp;status) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>PluralFormat::PluralFormat(const Locale &amp;locale, const PluralRules &amp;rules, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>PluralFormat&amp; PluralFormat::operator=(const PluralFormat &amp;other)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>PluralFormat::PluralFormat(const Locale &amp;locale, const PluralRules &amp;rules, const UnicodeString &amp;pattern, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>PluralFormat::PluralFormat(const PluralFormat &amp;other)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>PluralFormat::PluralFormat(const Locale &amp;locale, const UnicodeString &amp;pattern, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>UnicodeString&amp; PluralFormat::toPattern(UnicodeString &amp;appendTo)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>void PluralFormat::applyPattern(const UnicodeString &amp;pattern, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>PluralFormat::PluralFormat(const Locale &amp;locale, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>static UClassID PluralFormat::getStaticClassID(void)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>PluralFormat::PluralFormat(const UnicodeString &amp;pattern, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>UnicodeString&amp; PluralFormat::format(const Formattable &amp;obj, UnicodeString &amp;appendTo, FieldPosition &amp;pos, UErrorCode &amp;status) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>PluralFormat::~PluralFormat()</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>UClassID PluralFormat::getDynamicClassID() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>PluralFormat::PluralFormat(UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>PluralFormat::PluralFormat(const PluralRules &amp;rules, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurfmt.h</td><td>UBool PluralFormat::operator!=(const Format &amp;other) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>UBool PluralRules::operator!=(const PluralRules &amp;other) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>static PluralRules* PluralRules::createRules(const UnicodeString &amp;description, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>static UClassID PluralRules::getStaticClassID(void)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>PluralRules::PluralRules(UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>UnicodeString PluralRules::select(int32_t number) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>PluralRules* PluralRules::clone() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>UBool PluralRules::operator==(const PluralRules &amp;other) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>static PluralRules* PluralRules::createDefaultRules(UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>UnicodeString PluralRules::getKeywordOther() const</td><td>None</td><td>Internal</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>static PluralRules* PluralRules::forLocale(const Locale &amp;locale, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>PluralRules::~PluralRules()</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>UBool PluralRules::isKeyword(const UnicodeString &amp;keyword) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>PluralRules&amp; PluralRules::operator=(const PluralRules &amp;)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>PluralRules::PluralRules(const PluralRules &amp;other)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>UClassID PluralRules::getDynamicClassID() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>plurrule.h</td><td>StringEnumeration* PluralRules::getKeywords(UErrorCode &amp;status) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>int32_t RegexMatcher::getStackLimit() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>RegexMatcher&amp; RegexMatcher::useAnchoringBounds(UBool b)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>RegexMatcher&amp; RegexMatcher::region(int32_t start, int32_t limit, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>void RegexMatcher::setStackLimit(int32_t limit, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>int32_t RegexMatcher::getTimeLimit() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>RegexMatcher&amp; RegexMatcher::useTransparentBounds(UBool b)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>UBool RegexMatcher::requireEnd() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>void RegexMatcher::getMatchCallback(URegexMatchCallback *&amp;callback, const void *&amp;context, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>UBool RegexMatcher::hasTransparentBounds() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>void RegexMatcher::resetPreserveRegion()</td><td>None</td><td>Internal</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>int32_t RegexMatcher::regionEnd() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>void RegexMatcher::setMatchCallback(URegexMatchCallback *callback, const void *context, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>UBool RegexMatcher::hitEnd() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>int32_t RegexMatcher::regionStart() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>void RegexMatcher::setTimeLimit(int32_t limit, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>regex.h</td><td>UBool RegexMatcher::hasAnchoringBounds() const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>smpdtfmt.h</td><td>UBool SimpleDateFormat::isFieldUnitIgnored(UCalendarDateFields field) const</td><td>None</td><td>Internal</td>
</tr>
<tr STYLE="">
<td>smpdtfmt.h</td><td>static UBool SimpleDateFormat::isFieldUnitIgnored(const UnicodeString &amp;pattern, UCalendarDateFields field)</td><td>None</td><td>Internal</td>
</tr>
<tr STYLE="">
<td>smpdtfmt.h</td><td>const Locale&amp; SimpleDateFormat::getSmpFmtLocale(void) const</td><td>None</td><td>Internal</td>
</tr>
<tr STYLE="">
<td>timezone.h</td><td>static UnicodeString&amp; TimeZone::getCanonicalID(const UnicodeString &amp;id, UnicodeString &amp;canonicalID, UBool &amp;isSystemID, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>timezone.h</td><td>static UnicodeString&amp; TimeZone::getCanonicalID(const UnicodeString &amp;id, UnicodeString &amp;canonicalID, UErrorCode &amp;status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>ucal.h</td><td>UCalendar* ucal_clone(const UCalendar *cal, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>ucal.h</td><td>int32_t ucal_getCanonicalTimeZoneID(const UChar *id, int32_t len, UChar *result, int32_t resultCapacity, UBool *isSystemID, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>ucoleitr.h</td><td>int64_t ucol_previousProcessed(UCollationElements *elems, int32_t *ixLow, int32_t *ixHigh, UErrorCode *status)</td><td>None</td><td>Internal</td>
</tr>
<tr STYLE="">
<td>ucoleitr.h</td><td>int64_t ucol_nextProcessed(UCollationElements *elems, int32_t *ixLow, int32_t *ixHigh, UErrorCode *status)</td><td>None</td><td>Internal</td>
</tr>
<tr STYLE="">
<td>ucurr.h</td><td>int32_t ucurr_countCurrencies(const char *locale, UDate date, UErrorCode *ec)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>ucurr.h</td><td>int32_t ucurr_forLocaleAndDate(const char *locale, UDate date, int32_t index, UChar *buff, int32_t buffCapacity, UErrorCode *ec)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uloc.h</td><td>int32_t uloc_addLikelySubtags(const char *localeID, char *maximizedLocaleID, int32_t maximizedLocaleIDCapacity, UErrorCode *err)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uloc.h</td><td>int32_t uloc_minimizeSubtags(const char *localeID, char *minimizedLocaleID, int32_t minimizedLocaleIDCapacity, UErrorCode *err)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uloc.h</td><td>ULayoutType uloc_getLineOrientation(const char *localeId, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uloc.h</td><td>ULayoutType uloc_getCharacterOrientation(const char *localeId, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>UBool UnicodeSet::isBogus(void) const</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>void UnicodeSet::setToBogus()</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uniset.h</td><td>UnicodeSet&amp; UnicodeSet::removeAllStrings()</td><td>None</td><td>Internal</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>void uregex_getMatchCallback(const URegularExpression *regexp, URegexMatchCallback **callback, const void **context, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>void uregex_setRegion(URegularExpression *regexp, int32_t regionStart, int32_t regionLimit, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>int32_t uregex_getStackLimit(const URegularExpression *regexp, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>void uregex_setTimeLimit(URegularExpression *regexp, int32_t limit, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>int32_t uregex_regionStart(const URegularExpression *regexp, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>void uregex_useTransparentBounds(URegularExpression *regexp, UBool b, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>UBool uregex_requireEnd(const URegularExpression *regexp, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>void uregex_setStackLimit(URegularExpression *regexp, int32_t limit, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>U_CDECL_BEGIN typedef UBool U_CALLCONV URegexMatchCallback(const void *context, int32_t steps)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>UBool uregex_hitEnd(const URegularExpression *regexp, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>int32_t uregex_regionEnd(const URegularExpression *regexp, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>U_CDECL_END void uregex_setMatchCallback(URegularExpression *regexp, URegexMatchCallback *callback, const void *context, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>UBool uregex_hasAnchoringBounds(const URegularExpression *regexp, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>UBool uregex_hasTransparentBounds(const URegularExpression *regexp, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>void uregex_useAnchoringBounds(URegularExpression *regexp, UBool b, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>uregex.h</td><td>int32_t uregex_getTimeLimit(const URegularExpression *regexp, UErrorCode *status)</td><td>None</td><td>Draft</td>
</tr>
<tr STYLE="">
<td>usearch.h</td><td>UBool usearch_search(UStringSearch *strsrch, int32_t startIdx, int32_t *matchStart, int32_t *matchLimit, UErrorCode *status)</td><td>None</td><td>Internal</td>
</tr>
<tr STYLE="">
<td>usearch.h</td><td>UBool usearch_searchBackwards(UStringSearch *strsrch, int32_t startIdx, int32_t *matchStart, int32_t *matchLimit, UErrorCode *status)</td><td>None</td><td>Internal</td>
</tr>
</table>
<P></P>
<hr>
<p>
<i><font size="-1">Contents generated by StableAPI tool on Wed Jun 25 17:05:24 PDT 2008<br>Copyright (C) 2008, International Business Machines Corporation, All Rights Reserved.</font></i>
</p>
</body>
</html>
